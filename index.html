<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grilla con Simplex Noise, Carreteras y Casas</title>
    <style>
        * {
            box-sizing: border-box;
        }

        html,
        body {
            overflow-x: hidden;
        }

        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #e8e8e8;
            min-height: 100vh;
        }

        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .left-panel {
            width: 340px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .right-panel {
            flex: 1;
            min-width: 0;
            max-width: calc(100vw - 400px);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #00d4ff;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.3);
        }

        .panel {
            background: rgba(30, 30, 50, 0.9);
            border-radius: 12px;
            padding: 15px;
            border: 1px solid rgba(100, 100, 150, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .panel h3 {
            margin: 0 0 12px 0;
            color: #00d4ff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3);
            padding-bottom: 8px;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #4CAF50 0%, #2e7d32 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        button.danger {
            background: linear-gradient(135deg, #f44336 0%, #c62828 100%);
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
        }

        button.secondary {
            background: linear-gradient(135deg, #607d8b 0%, #455a64 100%);
            box-shadow: 0 2px 8px rgba(96, 125, 139, 0.3);
        }

        button.active {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4);
        }

        button.small {
            padding: 4px 8px;
            font-size: 11px;
        }

        input[type="number"],
        input[type="text"],
        select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(100, 100, 150, 0.5);
            background: rgba(20, 20, 40, 0.8);
            color: #e8e8e8;
            width: 70px;
            font-size: 13px;
        }

        select {
            width: 100%;
            cursor: pointer;
        }

        select option {
            background: rgba(20, 20, 40, 0.95);
            color: #e8e8e8;
        }

        input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 8px rgba(0, 212, 255, 0.3);
        }

        label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: #b0b0b0;
        }

        .canvas-container {
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            background: #0a0a15;
            min-height: 400px;
            max-height: 70vh;
        }

        .canvas-container.road-mode {
            border-color: #ff9800;
        }

        canvas {
            cursor: grab;
            transform-origin: 0 0;
            /* Crisp pixel rendering when canvas is scaled up */
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        canvas:active {
            cursor: grabbing;
        }

        canvas.road-mode {
            cursor: crosshair;
        }

        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
        }

        .zoom-controls button {
            width: 32px;
            height: 32px;
            padding: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-controls span {
            min-width: 60px;
            text-align: center;
            font-size: 12px;
            color: #b0b0b0;
        }

        .zoom-controls .zoom-slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(0, 212, 255, 0.3);
            border-radius: 2px;
            outline: none;
        }

        .zoom-controls .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #00d4ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .entity-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .entity-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(40, 40, 60, 0.6);
            border-radius: 6px;
            margin-bottom: 6px;
            font-size: 12px;
        }

        .entity-item .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .entity-item .visibility-btn {
            width: 24px;
            height: 24px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        .entity-item .delete-btn {
            width: 24px;
            height: 24px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .entity-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #a0a0a0;
        }

        .color-box {
            width: 16px;
            height: 16px;
            border: 1px solid #666;
            border-radius: 3px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .param-grid label {
            flex-direction: column;
            align-items: flex-start;
        }

        .param-grid input {
            width: 100%;
            margin-top: 4px;
        }

        .info-text {
            font-size: 12px;
            color: #888;
            margin-top: 8px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        #roadInfo {
            font-size: 13px;
            padding: 10px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 6px;
            border-left: 3px solid #00d4ff;
        }

        .scrollable-list::-webkit-scrollbar {
            width: 6px;
        }

        .scrollable-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 3px;
        }

        .scrollable-list::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.5);
            border-radius: 3px;
        }

        .stats {
            display: flex;
            gap: 15px;
            font-size: 12px;
            color: #888;
        }

        .stats span {
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 8px;
            border-radius: 4px;
        }

        .terrain-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .terrain-params label {
            flex-direction: column;
            align-items: flex-start;
        }

        .terrain-params input {
            width: 100%;
            margin-top: 4px;
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            white-space: normal;
            width: 200px;
            text-align: left;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .tooltip:hover::after {
            opacity: 1;
        }

        .section-divider {
            border-top: 1px solid rgba(100, 100, 150, 0.3);
            margin: 10px 0;
            padding-top: 10px;
        }

        .section-title {
            font-size: 12px;
            color: #00d4ff;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .material-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px;
            background: rgba(40, 40, 60, 0.6);
            border-radius: 4px;
            font-size: 11px;
        }

        .material-item input[type="number"] {
            width: 50px;
            padding: 4px 6px;
            font-size: 11px;
        }

        .material-item input[type="text"] {
            width: 60px;
            padding: 4px 6px;
            font-size: 11px;
        }

        .material-item input[type="color"] {
            width: 40px;
            height: 24px;
            padding: 0;
            border: 1px solid rgba(100, 100, 150, 0.5);
            border-radius: 4px;
            cursor: pointer;
            background: rgba(20, 20, 40, 0.8);
        }

        .material-item .delete-btn {
            width: 20px;
            height: 20px;
            padding: 0;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <h1>üó∫Ô∏è Map Maker - Carreteras y Casas</h1>

    <div class="main-container">
        <!-- Panel izquierdo: Controles -->
        <div class="left-panel">
            <!-- Par√°metros del Terreno -->
            <div class="panel">
                <h3>‚öôÔ∏è Par√°metros del Terreno</h3>
                <div class="terrain-params">
                    <label>
                        Ancho:
                        <input type="number" id="width" value="100" min="10" max="500">
                    </label>
                    <label>
                        Alto:
                        <input type="number" id="height" value="50" min="10" max="500">
                    </label>
                    <label class="tooltip"
                        data-tooltip="Tama√±o de cada celda en p√≠xeles. Afecta el tama√±o visual del mapa.">
                        Tama√±o celda:
                        <input type="number" id="cellSizeInput" value="128" min="4" max="256">
                    </label>
                    <label>
                        Escala:
                        <input type="number" id="scale" value="0.1" min="0.001" max="1" step="0.001">
                    </label>
                    <label>
                        Octavas:
                        <input type="number" id="octaves" value="4" min="1" max="8">
                    </label>
                    <label class="tooltip"
                        data-tooltip="Cu√°nto influye cada octava adicional. Con 0, solo cuenta la primera octava y el terreno es m√°s suave.">
                        Persistencia:
                        <input type="number" id="persistence" value="0" min="0" max="1" step="0.1">
                    </label>
                    <label class="tooltip"
                        data-tooltip="Cu√°nto aumenta el detalle en cada octava. Con 0, no hay detalle extra y el terreno es m√°s uniforme.">
                        Lacunaridad:
                        <input type="number" id="lacunarity" value="0" min="0" max="4" step="0.1">
                    </label>
                    <label class="tooltip"
                        data-tooltip="Resoluci√≥n del canvas. Menor = mejor rendimiento. Ej: con 128px celda y 100 celdas, 10% = 1280px canvas en vez de 12800px">
                        Resoluci√≥n canvas:
                        <select id="renderScaleSelect" onchange="setRenderScale(this.value)">
                            <option value="1">100% (Full)</option>
                            <option value="0.5">50%</option>
                            <option value="0.25">25%</option>
                            <option value="0.1" selected>10% (Default)</option>
                            <option value="0.05">5% (Fastest)</option>
                        </select>
                    </label>
                </div>
                <button style="margin-top: 10px; width: 100%;" onclick="generateGrid()">üîÑ Generar Terreno</button>
            </div>

            <!-- Panel de Carreteras -->
            <div class="panel">
                <h3>üõ£Ô∏è Carreteras</h3>
                <div class="controls" style="margin-bottom: 10px;">
                    <button id="roadModeBtn" onclick="toggleRoadMode()">
                        Modo Carretera: <span id="modeStatus">OFF</span>
                    </button>
                </div>
                <div class="param-grid" style="margin-bottom: 10px;">
                    <label class="tooltip"
                        data-tooltip="Ancho de la carretera en celdas. 1 = una celda, 2+ = se expande a los lados.">
                        Ancho carretera:
                        <input type="number" id="roadWidth" value="1" min="1" max="10">
                    </label>
                    <label class="tooltip"
                        data-tooltip="M√°ximo de casas que una carretera puede destruir por celda. 0 = evitar casas completamente.">
                        Max casas destruibles:
                        <input type="number" id="maxHousesToDestroy" value="1" min="0" max="10">
                    </label>
                </div>

                <div class="section-title">üèîÔ∏è Rango de Altitud</div>
                <div class="param-grid">
                    <label class="tooltip"
                        data-tooltip="Altitud m√≠nima para que una celda sea pasable por carretera (0-1)">
                        Altitud m√≠nima:
                        <input type="number" id="roadMinAltitude" value="0.2" min="0" max="1" step="0.05">
                    </label>
                    <label class="tooltip"
                        data-tooltip="Altitud m√°xima para que una celda sea pasable por carretera (0-1)">
                        Altitud m√°xima:
                        <input type="number" id="roadMaxAltitude" value="0.7" min="0" max="1" step="0.05">
                    </label>
                </div>

                <div class="info-text">
                    Activa el modo y haz clic en 2 puntos. El ancho expande la carretera a los lados. Destruye
                    √°rboles/piedras. Puede destruir casas seg√∫n config.
                </div>
                <div id="roadsList" class="entity-list scrollable-list">
                </div>
            </div>

            <!-- Panel de Casas -->
            <div class="panel">
                <h3>üè† Generador de Casas</h3>

                <div class="section-title">üìè Filtros de Altura</div>
                <div class="param-grid">
                    <label>
                        Altura m√≠nima:
                        <input type="number" id="minHeight" value="0.3" min="0" max="1" step="0.05">
                    </label>
                    <label>
                        Altura m√°xima:
                        <input type="number" id="maxHeight" value="0.7" min="0" max="1" step="0.05">
                    </label>
                </div>

                <div class="section-divider">
                    <div class="section-title">üéØ Atracci√≥n (0-100)</div>
                    <div class="param-grid">
                        <label class="tooltip"
                            data-tooltip="Atracci√≥n hacia carreteras. Mayor valor = m√°s casas cerca de carreteras. F√≥rmula: bonus = importancia/d¬≤">
                            Atracci√≥n carreteras:
                            <input type="number" id="roadImportance" value="50" min="0" max="100">
                        </label>
                        <label class="tooltip"
                            data-tooltip="Atracci√≥n hacia otras casas. Mayor valor = casas m√°s agrupadas. F√≥rmula: bonus = importancia/d¬≤">
                            Atracci√≥n vecinos:
                            <input type="number" id="neighborImportance" value="30" min="0" max="100">
                        </label>
                        <label class="tooltip"
                            data-tooltip="Atracci√≥n hacia el agua. Mayor valor = m√°s casas cerca del agua. F√≥rmula: bonus = importancia/d¬≤">
                            Atracci√≥n agua:
                            <input type="number" id="waterImportance" value="20" min="0" max="100">
                        </label>
                        <label>
                            Radio de b√∫squeda:
                            <input type="number" id="searchRadius" value="4" min="1" max="10">
                        </label>
                    </div>
                </div>

                <div class="section-divider">
                    <div class="section-title">üé≤ Probabilidad</div>
                    <div class="param-grid">
                        <label>
                            Probabilidad base (%):
                            <input type="number" id="houseProbability" value="30" min="0" max="100">
                        </label>
                        <label>
                            Max casas/celda:
                            <input type="number" id="maxHousesPerCell" value="3" min="1" max="10">
                        </label>
                    </div>
                </div>

                <div class="controls" style="margin-top: 10px;">
                    <button onclick="generateHouses()">üèóÔ∏è Generar Casas</button>
                    <button class="danger" onclick="clearAllHouses()">üóëÔ∏è Limpiar Casas</button>
                </div>
                <div id="housesList" class="entity-list scrollable-list" style="margin-top: 10px;">
                </div>
            </div>

            <!-- Panel de Piedras -->
            <div class="panel">
                <h3>ü™® Generador de Piedras</h3>
                <div class="info-text" style="margin-bottom: 10px;">
                    Las piedras aparecen m√°s en monta√±as. No en agua, casas, carreteras ni monta√±as altas.
                </div>
                <div class="param-grid">
                    <label class="tooltip"
                        data-tooltip="Probabilidad base de generar piedra en celdas v√°lidas (0-100%)">
                        Probabilidad (%):
                        <input type="number" id="rockProbability" value="15" min="0" max="100">
                    </label>
                    <label class="tooltip" data-tooltip="M√°ximo de piedras por celda">
                        Max piedras/celda:
                        <input type="number" id="maxRocksPerCell" value="3" min="1" max="10">
                    </label>
                    <label class="tooltip" data-tooltip="Radio m√≠nimo de piedra (relativo a celda, 0.05-0.3)">
                        Radio m√≠n:
                        <input type="number" id="rockMinRadius" value="0.08" min="0.05" max="0.3" step="0.01">
                    </label>
                    <label class="tooltip" data-tooltip="Radio m√°ximo de piedra (relativo a celda, 0.1-0.5)">
                        Radio m√°x:
                        <input type="number" id="rockMaxRadius" value="0.25" min="0.1" max="0.5" step="0.01">
                    </label>
                </div>
                <div class="controls" style="margin-top: 10px;">
                    <button onclick="generateRocks()">ü™® Generar Piedras</button>
                    <button class="danger" onclick="clearAllRocks()">üóëÔ∏è Limpiar Piedras</button>
                </div>
                <div id="rocksList" class="entity-list scrollable-list" style="margin-top: 10px;"></div>
            </div>

            <!-- Panel de √Årboles -->
            <div class="panel">
                <h3>üå≤ Generador de √Årboles</h3>
                <div class="info-text" style="margin-bottom: 10px;">
                    Altura ideal: 20%. No en agua, carreteras ni monta√±as altas. Evitan casas.
                </div>
                <div class="param-grid">
                    <label class="tooltip" data-tooltip="Probabilidad base de generar √°rbol (0-100%)">
                        Probabilidad (%):
                        <input type="number" id="treeProbability" value="25" min="0" max="100">
                    </label>
                    <label class="tooltip" data-tooltip="M√°ximo de √°rboles por celda">
                        Max √°rboles/celda:
                        <input type="number" id="maxTreesPerCell" value="4" min="1" max="10">
                    </label>
                    <label class="tooltip" data-tooltip="Radio m√≠nimo del tronco (0.03-0.1)">
                        Radio m√≠n:
                        <input type="number" id="treeMinRadius" value="0.05" min="0.03" max="0.1" step="0.01">
                    </label>
                    <label class="tooltip" data-tooltip="Radio m√°ximo del tronco (0.08-0.2)">
                        Radio m√°x:
                        <input type="number" id="treeMaxRadius" value="0.12" min="0.08" max="0.2" step="0.01">
                    </label>
                    <label class="tooltip" data-tooltip="Penalizaci√≥n por cada casa cercana (0-100)">
                        Penaliz. casas:
                        <input type="number" id="treeCasePenalty" value="30" min="0" max="100">
                    </label>
                    <label class="tooltip" data-tooltip="Radio de b√∫squeda de casas cercanas">
                        Radio b√∫squeda:
                        <input type="number" id="treeSearchRadius" value="3" min="1" max="8">
                    </label>
                </div>
                <div class="controls" style="margin-top: 10px;">
                    <button onclick="generateTrees()">üå≤ Generar √Årboles</button>
                    <button class="danger" onclick="clearAllTrees()">üóëÔ∏è Limpiar √Årboles</button>
                </div>
                <div id="treesList" class="entity-list scrollable-list" style="margin-top: 10px;"></div>
            </div>

        </div>

        <!-- Panel derecho: Canvas y leyenda -->
        <div class="right-panel">
            <div class="panel">
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="gridCanvas"></canvas>
                </div>
                <div class="zoom-controls">
                    <button onclick="zoomOut()" title="Alejar">‚ûñ</button>
                    <input type="range" class="zoom-slider" id="zoomSlider" min="1" max="300" value="100"
                        onchange="setZoom(this.value)">
                    <button onclick="zoomIn()" title="Acercar">‚ûï</button>
                    <span id="zoomLevel">100%</span>
                    <button class="secondary" onclick="fitToView()" title="Ajustar a la vista">üîÑ</button>
                </div>
                <div id="roadInfo" style="margin-top: 10px;">Genera un terreno para comenzar.</div>
                <div class="stats" style="margin-top: 10px;">
                    <span id="statsRoads">Carreteras: 0</span>
                    <span id="statsHouses">Casas: 0</span>
                    <span id="statsRocks">Piedras: 0</span>
                    <span id="statsTrees">√Årboles: 0</span>
                    <span id="statsCells">Celdas: 0</span>
                </div>
            </div>

            <div class="panel">
                <h3>üìä Leyenda</h3>
                <div class="legend" id="legendContainer">
                    <!-- Las leyendas se generar√°n din√°micamente -->
                </div>
            </div>

            <!-- Acciones Globales -->
            <div class="panel">
                <h3>üîß Acciones</h3>
                <div class="controls">
                    <button class="secondary small" onclick="toggleAllRoads(true)">üëÅÔ∏è Carreteras</button>
                    <button class="secondary small" onclick="toggleAllRoads(false)">üôà Carreteras</button>
                    <button class="secondary small" onclick="toggleAllHouses(true)">üëÅÔ∏è Casas</button>
                    <button class="secondary small" onclick="toggleAllHouses(false)">üôà Casas</button>
                </div>
                <div class="controls" style="margin-top: 8px;">
                    <button class="secondary small" onclick="toggleAllRocks(true)">üëÅÔ∏è Piedras</button>
                    <button class="secondary small" onclick="toggleAllRocks(false)">üôà Piedras</button>
                    <button class="secondary small" onclick="toggleAllTrees(true)">üëÅÔ∏è √Årboles</button>
                    <button class="secondary small" onclick="toggleAllTrees(false)">üôà √Årboles</button>
                </div>
                <div class="controls" style="margin-top: 8px;">
                    <button class="danger" onclick="clearAll()">‚ö†Ô∏è Limpiar Todo</button>
                </div>
            </div>

            <!-- Exportar -->
            <div class="panel">
                <h3>üíæ Exportar</h3>

                <div class="section-divider">
                    <div class="section-title">üé® Definici√≥n de Materiales</div>
                    <div class="info-text" style="margin-bottom: 8px; font-size: 11px;">
                        Define rangos de altitud, n√∫mero y color de material. Los colores se aplican al mapa.
                    </div>
                    <div id="materialsList"
                        style="display: flex; flex-direction: column; gap: 6px; margin-bottom: 10px;">
                        <!-- Material definitions will be inserted here -->
                    </div>
                    <button class="secondary small" style="width: 100%;" onclick="addMaterialDefinition()">‚ûï Agregar
                        Material</button>

                    <div style="margin-top: 10px; padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                            <input type="checkbox" id="roadsAsMaterial" onchange="toggleRoadMaterial()">
                            <span style="flex: 1;">Carreteras como material</span>
                        </label>
                        <div id="roadMaterialInput" style="display: none; margin-top: 8px;">
                            <label style="font-size: 11px;">
                                N√∫mero de material:
                                <input type="number" id="roadMaterialNumber" value="99" min="0" max="255"
                                    style="width: 60px;">
                            </label>
                        </div>
                    </div>
                </div>

                <div style="margin-top: 15px;">
                    <label style="font-size: 12px; color: #b0b0b0; margin-bottom: 6px; display: block;">
                        Tipo de exportaci√≥n:
                    </label>
                    <select id="exportType" style="width: 100%; margin-bottom: 10px;">
                        <option value="complete">Exportaci√≥n Completa (Grid + Entidades + Materiales)</option>
                        <option value="materials">Solo Materiales (Array 2D de n√∫meros)</option>
                    </select>
                </div>

                <button style="width: 100%;" onclick="exportMapData()">üì• Exportar JSON</button>
            </div>
        </div>
    </div>

    <script>
        // ============== SIMPLEX NOISE ==============
        class SimplexNoise {
            constructor() {
                this.perm = [];
                for (let i = 0; i < 256; i++) {
                    this.perm[i] = i;
                }
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.perm[i], this.perm[j]] = [this.perm[j], this.perm[i]];
                }
                for (let i = 0; i < 256; i++) {
                    this.perm[256 + i] = this.perm[i];
                }
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 15;
                const u = h < 8 ? x : y;
                const v = h < 4 ? y : h === 12 || h === 14 ? x : 0;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;

                x -= Math.floor(x);
                y -= Math.floor(y);

                const u = this.fade(x);
                const v = this.fade(y);

                const a = this.perm[X] + Y;
                const aa = this.perm[a];
                const ab = this.perm[a + 1];
                const b = this.perm[X + 1] + Y;
                const ba = this.perm[b];
                const bb = this.perm[b + 1];

                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[aa], x, y),
                        this.grad(this.perm[ba], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[ab], x, y - 1),
                        this.grad(this.perm[bb], x - 1, y - 1))
                );
            }
        }

        // ============== ESTADO GLOBAL ==============
        let grid = [];
        let roads = [];
        let houses = [];
        let simplex;
        let roadMode = false;
        let selectedCells = [];
        let roadIdCounter = 1;
        let houseGroupIdCounter = 1;
        let rocks = [];
        let trees = [];
        let rockGroupIdCounter = 1;
        let treeGroupIdCounter = 1;

        // Material definitions
        let materialDefinitions = [];
        let materialIdCounter = 1;

        let cellSize = 12;
        const MIN_PASSABLE = 0.25;
        const MAX_PASSABLE = 0.75;
        const WATER_THRESHOLD = 0.3; // Por debajo de esto es agua

        // Estado de zoom y pan
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

        // Render scale - canvas pixel resolution (1 = full, 0.1 = 10% pixels)
        // E.g., with cellSize=128 and 100 cells, full = 12800px canvas, 0.1 = 1280px canvas
        let renderScale = 0.1; // Default 10% resolution for performance

        const roadColors = [
            '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
            '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE'
        ];

        // ============== GENERACI√ìN DE GRILLA ==============
        function generateGrid() {
            const w = parseInt(document.getElementById('width').value);
            const h = parseInt(document.getElementById('height').value);
            const scale = parseFloat(document.getElementById('scale').value);
            const octaves = parseInt(document.getElementById('octaves').value);
            const persistence = parseFloat(document.getElementById('persistence').value);
            const lacunarity = parseFloat(document.getElementById('lacunarity').value);
            cellSize = parseInt(document.getElementById('cellSizeInput').value) || 12;

            simplex = new SimplexNoise();
            grid = [];
            roads = [];
            houses = [];
            rocks = [];
            trees = [];
            roadIdCounter = 1;
            houseGroupIdCounter = 1;
            rockGroupIdCounter = 1;
            treeGroupIdCounter = 1;

            // Will fit to view after drawing

            for (let y = 0; y < h; y++) {
                grid[y] = [];
                for (let x = 0; x < w; x++) {
                    let noise = 0;
                    let amplitude = 1;
                    let frequency = scale;
                    let maxValue = 0;

                    for (let i = 0; i < octaves; i++) {
                        noise += simplex.noise(x * frequency, y * frequency) * amplitude;
                        maxValue += amplitude;
                        amplitude *= persistence;
                        frequency *= lacunarity;
                    }

                    // Si maxValue es 0 (por persistencia 0), usar solo el primer noise
                    if (maxValue === 0) maxValue = 1;
                    noise = noise / maxValue;
                    const normalizedNoise = (noise + 1) / 2;

                    grid[y][x] = {
                        noise: normalizedNoise,
                        isPassable: normalizedNoise >= MIN_PASSABLE && normalizedNoise <= MAX_PASSABLE,
                        isWater: normalizedNoise < WATER_THRESHOLD,
                        roadIds: [],
                        houses: [],
                        rocks: [],
                        trees: []
                    };
                }
            }

            updateUI();
            drawGrid();
            fitToView();
            showInfo('Terreno generado. Activa el modo carretera para crear caminos.');
        }

        // ============== COLORES ==============
        function getTerrainColor(value) {
            // Use material definitions for colors
            for (const mat of materialDefinitions) {
                if (value >= mat.minAltitude && value < mat.maxAltitude) {
                    return mat.color;
                }
            }
            // Fallback to default colors if no material matches
            if (value < MIN_PASSABLE) return '#0a1f2e';
            if (value > MAX_PASSABLE) return '#4a4a4a';
            if (value < 0.3) return '#1a4d2e';
            if (value < 0.6) return '#8B4513';
            return '#90EE90';
        }

        // ============== ZOOM Y PAN ==============
        function getMinZoom() {
            if (!grid || grid.length === 0 || !grid[0]) return 0.1;

            const container = document.getElementById('canvasContainer');
            const containerRect = container.getBoundingClientRect();

            const fullWidth = grid[0].length * cellSize;
            const fullHeight = grid.length * cellSize;

            const padding = 20;
            const zoomX = (containerRect.width - padding * 2) / fullWidth;
            const zoomY = (containerRect.height - padding * 2) / fullHeight;

            return Math.min(zoomX, zoomY);
        }

        function updateZoomUI() {
            const zoomPercent = Math.round(zoom * 100);
            document.getElementById('zoomLevel').textContent = `${zoomPercent}%`;
            document.getElementById('zoomSlider').value = zoomPercent;
        }

        function setZoom(percent) {
            const minZoom = getMinZoom();
            zoom = Math.max(minZoom, percent / 100);
            updateZoomUI();
            applyTransform();
        }

        function zoomIn() {
            zoom = Math.min(3, zoom + 0.1);
            updateZoomUI();
            applyTransform();
        }

        function zoomOut() {
            const minZoom = getMinZoom();
            zoom = Math.max(minZoom, zoom - 0.1);
            updateZoomUI();
            applyTransform();
        }

        function resetView() {
            zoom = 1;
            panX = 0;
            panY = 0;
            updateZoomUI();
            applyTransform();
        }

        function fitToView() {
            if (!grid || grid.length === 0 || !grid[0]) return;

            const container = document.getElementById('canvasContainer');
            const containerRect = container.getBoundingClientRect();

            // Calculate full canvas dimensions
            const fullWidth = grid[0].length * cellSize;
            const fullHeight = grid.length * cellSize;

            // Use the minimum zoom that fits the whole map
            zoom = Math.min(getMinZoom(), 1); // Cap at 100% max

            // Center the map
            const scaledWidth = fullWidth * zoom;
            const scaledHeight = fullHeight * zoom;
            panX = (containerRect.width - scaledWidth) / 2;
            panY = (containerRect.height - scaledHeight) / 2;

            updateZoomUI();
            applyTransform();
        }

        function applyTransform() {
            const canvas = document.getElementById('gridCanvas');
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
        }

        function setRenderScale(value) {
            renderScale = parseFloat(value);
            drawGrid();
        }

        function handleWheel(event) {
            event.preventDefault();

            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();

            // Mouse position relative to container
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Old zoom
            const oldZoom = zoom;

            // Calculate new zoom
            const delta = event.deltaY > 0 ? -0.1 : 0.1;
            const minZoom = getMinZoom();
            zoom = Math.max(minZoom, Math.min(3, zoom + delta));

            // Adjust pan to zoom towards mouse position
            const zoomRatio = zoom / oldZoom;
            panX = mouseX - (mouseX - panX) * zoomRatio;
            panY = mouseY - (mouseY - panY) * zoomRatio;

            updateZoomUI();
            applyTransform();
        }

        function handlePanStart(event) {
            // Don't pan in road mode or if right-clicking
            if (roadMode || event.button !== 0) return;

            isPanning = true;
            lastPanX = event.clientX;
            lastPanY = event.clientY;
            event.preventDefault();
        }

        function handlePanMove(event) {
            if (!isPanning) return;

            const deltaX = event.clientX - lastPanX;
            const deltaY = event.clientY - lastPanY;

            panX += deltaX;
            panY += deltaY;

            lastPanX = event.clientX;
            lastPanY = event.clientY;

            applyTransform();
        }

        function handlePanEnd() {
            isPanning = false;
        }

        // ============== DIBUJADO ==============
        function drawGrid() {
            if (!grid || grid.length === 0 || !grid[0]) return;

            const canvas = document.getElementById('gridCanvas');
            const ctx = canvas.getContext('2d');

            // Calculate scaled dimensions
            // renderScale reduces the actual canvas pixels (e.g., 0.1 = 10% of full resolution)
            const scaledCellSize = cellSize * renderScale;
            const fullWidth = grid[0].length * cellSize;
            const fullHeight = grid.length * cellSize;
            const canvasWidth = Math.ceil(grid[0].length * scaledCellSize);
            const canvasHeight = Math.ceil(grid.length * scaledCellSize);

            // Set canvas to scaled size
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Use CSS to scale canvas back to full visual size
            canvas.style.width = fullWidth + 'px';
            canvas.style.height = fullHeight + 'px';

            // Apply pan and zoom transform
            applyTransform();

            // Use scaled cell size for all drawing
            const cs = scaledCellSize;

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];
                    const isSelected = selectedCells.some(c => c.x === x && c.y === y);

                    // Dibujar terreno base
                    ctx.fillStyle = getTerrainColor(cell.noise);
                    ctx.fillRect(x * cs, y * cs, cs, cs);

                    // Dibujar carretera si hay alguna visible
                    const visibleRoad = roads.find(r => r.visible && r.cells.some(c => c.x === x && c.y === y));
                    if (visibleRoad) {
                        ctx.fillStyle = visibleRoad.color;
                        ctx.fillRect(x * cs, y * cs, cs, cs);
                    }

                    // Dibujar casas (solo si no hay carretera visible)
                    if (!visibleRoad) {
                        const visibleHouses = cell.houses.filter(h => {
                            const group = houses.find(g => g.id === h.groupId);
                            return group && group.visible;
                        });

                        if (visibleHouses.length > 0) {
                            visibleHouses.forEach(house => {
                                // Usar dimensiones de la casa o valores por defecto
                                const houseW = (house.width || HOUSE_WIDTH) * cs;
                                const houseH = (house.height || HOUSE_HEIGHT) * cs;
                                const hx = x * cs + house.offsetX * cs;
                                const hy = y * cs + house.offsetY * cs;

                                // Cuerpo de la casa (rect√°ngulo)
                                ctx.fillStyle = '#e74c3c';
                                ctx.fillRect(hx, hy, houseW, houseH);

                                // Techo (tri√°ngulo)
                                ctx.fillStyle = '#c0392b';
                                ctx.beginPath();
                                ctx.moveTo(hx, hy);
                                ctx.lineTo(hx + houseW / 2, hy - houseH * 0.4);
                                ctx.lineTo(hx + houseW, hy);
                                ctx.fill();

                                // Borde de la casa
                                ctx.strokeStyle = '#922b21';
                                ctx.lineWidth = Math.max(0.5, cs * 0.04);
                                ctx.strokeRect(hx, hy, houseW, houseH);
                            });
                        }
                    }

                    // Dibujar piedras (solo si no hay carretera visible)
                    if (!visibleRoad) {
                        const visibleRocks = cell.rocks.filter(r => {
                            const group = rocks.find(g => g.id === r.groupId);
                            return group && group.visible;
                        });

                        visibleRocks.forEach(rock => {
                            const rx = x * cs + rock.offsetX * cs;
                            const ry = y * cs + rock.offsetY * cs;
                            const rRadius = rock.radius * cs;

                            // Sombra de la piedra
                            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                            ctx.beginPath();
                            ctx.ellipse(rx + rRadius * 0.15, ry + rRadius * 0.15, rRadius, rRadius * 0.7, 0, 0, Math.PI * 2);
                            ctx.fill();

                            // Cuerpo de la piedra (gris) - usar shade guardado
                            const grayShade = rock.shade || 100;
                            ctx.fillStyle = `rgb(${grayShade}, ${grayShade - 10}, ${grayShade - 5})`;
                            ctx.beginPath();
                            ctx.arc(rx, ry, rRadius, 0, Math.PI * 2);
                            ctx.fill();

                            // Brillo
                            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                            ctx.beginPath();
                            ctx.arc(rx - rRadius * 0.3, ry - rRadius * 0.3, rRadius * 0.3, 0, Math.PI * 2);
                            ctx.fill();

                            // Borde
                            ctx.strokeStyle = '#4a4a4a';
                            ctx.lineWidth = Math.max(0.5, cs * 0.04);
                            ctx.beginPath();
                            ctx.arc(rx, ry, rRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        });
                    }

                    // Dibujar √°rboles
                    const visibleTrees = cell.trees.filter(t => {
                        const group = trees.find(g => g.id === t.groupId);
                        return group && group.visible;
                    });

                    visibleTrees.forEach(tree => {
                        const tx = x * cs + tree.offsetX * cs;
                        const ty = y * cs + tree.offsetY * cs;
                        const tRadius = tree.radius * cs;
                        const crownRadius = tRadius * 2.5; // Copa del √°rbol m√°s grande que el tronco

                        // Sombra del √°rbol
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
                        ctx.beginPath();
                        ctx.ellipse(tx + crownRadius * 0.2, ty + crownRadius * 0.2, crownRadius, crownRadius * 0.6, 0, 0, Math.PI * 2);
                        ctx.fill();

                        // Copa del √°rbol (verde oscuro base)
                        ctx.fillStyle = '#1a5f1a';
                        ctx.beginPath();
                        ctx.arc(tx, ty, crownRadius, 0, Math.PI * 2);
                        ctx.fill();

                        // Copa interior (verde m√°s claro)
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.arc(tx - crownRadius * 0.15, ty - crownRadius * 0.15, crownRadius * 0.7, 0, Math.PI * 2);
                        ctx.fill();

                        // Brillo
                        ctx.fillStyle = 'rgba(144, 238, 144, 0.4)';
                        ctx.beginPath();
                        ctx.arc(tx - crownRadius * 0.3, ty - crownRadius * 0.3, crownRadius * 0.35, 0, Math.PI * 2);
                        ctx.fill();

                        // Borde de la copa
                        ctx.strokeStyle = '#0d3d0d';
                        ctx.lineWidth = Math.max(0.5, cs * 0.04);
                        ctx.beginPath();
                        ctx.arc(tx, ty, crownRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    });

                    // Borde de selecci√≥n
                    if (isSelected) {
                        ctx.strokeStyle = '#FF00FF';
                        ctx.lineWidth = Math.max(2, cs * 0.08);
                        const selOffset = Math.max(1, cs * 0.04);
                        ctx.strokeRect(x * cs + selOffset, y * cs + selOffset, cs - 2 * selOffset, cs - 2 * selOffset);
                    }

                    // Borde de celda
                    ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                    ctx.lineWidth = Math.max(1, cs * 0.02);
                    ctx.strokeRect(x * cs, y * cs, cs, cs);
                }
            }

            updateStats();
        }

        // ============== CARRETERAS ==============
        function toggleRoadMode() {
            roadMode = !roadMode;
            selectedCells = [];

            const canvas = document.getElementById('gridCanvas');
            const container = document.getElementById('canvasContainer');
            const modeStatus = document.getElementById('modeStatus');
            const btn = document.getElementById('roadModeBtn');

            if (roadMode) {
                canvas.classList.add('road-mode');
                container.classList.add('road-mode');
                modeStatus.textContent = 'ON';
                btn.classList.add('active');
                const minAlt = parseFloat(document.getElementById('roadMinAltitude').value) || 0;
                const maxAlt = parseFloat(document.getElementById('roadMaxAltitude').value) || 1;
                showInfo(`Modo carretera activado. Haz clic en 2 celdas con altitud entre ${minAlt}-${maxAlt} para crear una carretera.`);
            } else {
                canvas.classList.remove('road-mode');
                container.classList.remove('road-mode');
                modeStatus.textContent = 'OFF';
                btn.classList.remove('active');
                showInfo('Modo carretera desactivado.');
            }

            drawGrid();
        }

        function isPassable(x, y) {
            if (!grid || !grid[y] || !grid[y][x]) return false;
            return grid[y][x].isPassable;
        }

        // Verifica si una celda puede ser parte de una carretera
        // Considera el m√°ximo de casas destruibles configurado y el rango de altitud
        function canBeRoad(x, y, maxHousesToDestroy = null) {
            if (!grid || !grid[y] || !grid[y][x]) return false;
            const cell = grid[y][x];
            if (!cell.isPassable) return false;

            // Verificar rango de altitud
            const minAltitude = parseFloat(document.getElementById('roadMinAltitude').value) || 0;
            const maxAltitude = parseFloat(document.getElementById('roadMaxAltitude').value) || 1;

            if (cell.noise < minAltitude || cell.noise > maxAltitude) {
                return false; // Fuera del rango de altitud permitido
            }

            // Si no se especifica, obtener del input
            if (maxHousesToDestroy === null) {
                maxHousesToDestroy = parseInt(document.getElementById('maxHousesToDestroy').value) || 0;
            }

            // Puede ser carretera si no hay casas, o si las casas son <= al m√°ximo destruible
            return cell.houses.length <= maxHousesToDestroy;
        }

        // Obtiene el costo extra por destruir casas en una celda
        function getHouseDestroyCost(x, y) {
            if (!grid || !grid[y] || !grid[y][x]) return 0;
            const cell = grid[y][x];
            // Cada casa a√±ade un costo significativo (50) para que el pathfinding prefiera evitarlas
            return cell.houses.length * 50;
        }

        // Verifica si una celda tiene carretera
        function hasRoad(x, y) {
            if (!grid || !grid[y] || !grid[y][x]) return false;
            return grid[y][x].roadIds.length > 0;
        }

        function handleCanvasClick(event) {
            if (!roadMode || !grid || grid.length === 0) return;

            const canvas = document.getElementById('gridCanvas');
            const container = document.getElementById('canvasContainer');
            const rect = container.getBoundingClientRect();

            // Account for pan and zoom
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Convert to canvas coordinates (reverse transform)
            const canvasX = (mouseX - panX) / zoom;
            const canvasY = (mouseY - panY) / zoom;

            const x = Math.floor(canvasX / cellSize);
            const y = Math.floor(canvasY / cellSize);

            if (y >= 0 && y < grid.length && x >= 0 && x < grid[0].length) {
                if (!canBeRoad(x, y)) {
                    const cell = grid[y][x];
                    const minAltitude = parseFloat(document.getElementById('roadMinAltitude').value) || 0;
                    const maxAltitude = parseFloat(document.getElementById('roadMaxAltitude').value) || 1;

                    if (!isPassable(x, y)) {
                        showInfo(`Celda (${x}, ${y}) es impasable.`);
                    } else if (cell.noise < minAltitude || cell.noise > maxAltitude) {
                        showInfo(`Celda (${x}, ${y}) altitud ${cell.noise.toFixed(2)} fuera del rango permitido (${minAltitude}-${maxAltitude}).`);
                    } else {
                        showInfo(`Celda (${x}, ${y}) tiene casas. No puede ser inicio/fin de carretera.`);
                    }
                    return;
                }

                const index = selectedCells.findIndex(c => c.x === x && c.y === y);
                if (index !== -1) {
                    selectedCells.splice(index, 1);
                    showInfo(`Celda (${x}, ${y}) deseleccionada. ${selectedCells.length}/2 celdas.`);
                } else if (selectedCells.length < 2) {
                    selectedCells.push({ x, y });
                    showInfo(`Celda (${x}, ${y}) seleccionada. ${selectedCells.length}/2 celdas.`);

                    if (selectedCells.length === 2) {
                        setTimeout(createRoad, 100);
                    }
                } else {
                    selectedCells = [{ x, y }];
                    showInfo(`Nueva selecci√≥n. Celda (${x}, ${y}) seleccionada. 1/2 celdas.`);
                }

                drawGrid();
            }
        }

        function createRoad() {
            if (selectedCells.length !== 2) return;

            const start = selectedCells[0];
            const end = selectedCells[1];
            const roadWidth = parseInt(document.getElementById('roadWidth').value) || 1;
            const maxHousesToDestroy = parseInt(document.getElementById('maxHousesToDestroy').value) || 0;

            const basePath = aStar(start, end);

            if (basePath.length === 0) {
                const minAlt = parseFloat(document.getElementById('roadMinAltitude').value) || 0;
                const maxAlt = parseFloat(document.getElementById('roadMaxAltitude').value) || 1;
                showInfo(`No se pudo encontrar un camino (puede estar bloqueado por casas, zonas impasables o celdas fuera del rango de altitud ${minAlt}-${maxAlt}).`);
                selectedCells = [];
                drawGrid();
                return;
            }

            // Expand the path based on road width
            const path = expandRoadPath(basePath, roadWidth, maxHousesToDestroy);

            const roadEntity = {
                id: roadIdCounter++,
                name: `Carretera ${roadIdCounter - 1}`,
                cells: path,
                visible: true,
                color: roadColors[(roadIdCounter - 2) % roadColors.length],
                start: { x: start.x, y: start.y },
                end: { x: end.x, y: end.y },
                width: roadWidth
            };

            roads.push(roadEntity);

            // Contadores de elementos destruidos
            let destroyedHouses = 0;
            let destroyedRocks = 0;
            let destroyedTrees = 0;

            path.forEach(cell => {
                const cellData = grid[cell.y][cell.x];

                // Agregar ID de carretera a la celda
                cellData.roadIds.push(roadEntity.id);

                // Destruir casas en esta celda
                if (cellData.houses.length > 0) {
                    destroyedHouses += cellData.houses.length;
                    // Actualizar contadores en los grupos de casas
                    cellData.houses.forEach(house => {
                        const group = houses.find(g => g.id === house.groupId);
                        if (group) {
                            group.count--;
                        }
                    });
                    cellData.houses = [];
                }

                // Destruir piedras en esta celda
                if (cellData.rocks.length > 0) {
                    destroyedRocks += cellData.rocks.length;
                    // Actualizar contadores en los grupos de piedras
                    cellData.rocks.forEach(rock => {
                        const group = rocks.find(g => g.id === rock.groupId);
                        if (group) {
                            group.count--;
                        }
                    });
                    cellData.rocks = [];
                }

                // Destruir √°rboles en esta celda
                if (cellData.trees.length > 0) {
                    destroyedTrees += cellData.trees.length;
                    // Actualizar contadores en los grupos de √°rboles
                    cellData.trees.forEach(tree => {
                        const group = trees.find(g => g.id === tree.groupId);
                        if (group) {
                            group.count--;
                        }
                    });
                    cellData.trees = [];
                }
            });

            // Limpiar grupos vac√≠os
            houses = houses.filter(g => g.count > 0);
            rocks = rocks.filter(g => g.count > 0);
            trees = trees.filter(g => g.count > 0);

            selectedCells = [];
            updateUI();
            drawGrid();

            // Mensaje informativo
            let msg = `Carretera creada (ancho ${roadWidth}): ${path.length} celdas desde (${start.x},${start.y}) hasta (${end.x},${end.y})`;
            const destroyed = [];
            if (destroyedHouses > 0) destroyed.push(`${destroyedHouses} casas`);
            if (destroyedRocks > 0) destroyed.push(`${destroyedRocks} piedras`);
            if (destroyedTrees > 0) destroyed.push(`${destroyedTrees} √°rboles`);
            if (destroyed.length > 0) {
                msg += `. Destruidos: ${destroyed.join(', ')}.`;
            }
            showInfo(msg);
        }

        function deleteRoad(roadId) {
            const roadIndex = roads.findIndex(r => r.id === roadId);
            if (roadIndex === -1) return;

            const road = roads[roadIndex];

            road.cells.forEach(cell => {
                const cellData = grid[cell.y][cell.x];
                cellData.roadIds = cellData.roadIds.filter(id => id !== roadId);
            });

            roads.splice(roadIndex, 1);
            updateUI();
            drawGrid();
        }

        function toggleRoadVisibility(roadId) {
            const road = roads.find(r => r.id === roadId);
            if (road) {
                road.visible = !road.visible;
                updateUI();
                drawGrid();
            }
        }

        function toggleAllRoads(visible) {
            roads.forEach(r => r.visible = visible);
            updateUI();
            drawGrid();
        }

        // ============== CASAS ==============
        // Dimensiones de las casas (relativas a la celda, 0-1)
        const HOUSE_WIDTH = 0.25;
        const HOUSE_HEIGHT = 0.20;
        const HOUSE_MARGIN = 0.05; // Margen desde el borde de la celda

        // Calcula el bonus por cercan√≠a usando importance/d¬≤
        // Retorna un valor alto si hay elementos cerca, bajo si est√°n lejos
        function calculateProximityBonus(x, y, radius, importance, checkFn) {
            if (importance <= 0) return 0;

            let bonus = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx === 0 && dy === 0) continue;

                    const nx = x + dx;
                    const ny = y + dy;

                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        if (checkFn(nx, ny)) {
                            const d2 = dx * dx + dy * dy;
                            bonus += importance / d2;
                        }
                    }
                }
            }
            return bonus;
        }


        // Verifica si dos rect√°ngulos se superponen
        function rectanglesOverlap(x1, y1, w1, h1, x2, y2, w2, h2) {
            return !(x1 + w1 <= x2 || x2 + w2 <= x1 || y1 + h1 <= y2 || y2 + h2 <= y1);
        }

        // Intenta colocar una casa sin colisi√≥n en una celda
        // Verifica colisiones con otras casas, piedras y √°rboles
        function tryPlaceHouse(cellX, cellY, existingHousesInCell, existingRocksInCell = [], existingTreesInCell = [], maxAttempts = 30) {
            const availableWidth = 1 - 2 * HOUSE_MARGIN - HOUSE_WIDTH;
            const availableHeight = 1 - 2 * HOUSE_MARGIN - HOUSE_HEIGHT;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const newX = HOUSE_MARGIN + Math.random() * availableWidth;
                const newY = HOUSE_MARGIN + Math.random() * availableHeight;

                let collision = false;

                // Verificar colisi√≥n con casas existentes
                for (const existing of existingHousesInCell) {
                    const existingW = existing.width || HOUSE_WIDTH;
                    const existingH = existing.height || HOUSE_HEIGHT;

                    if (rectanglesOverlap(
                        newX, newY, HOUSE_WIDTH, HOUSE_HEIGHT,
                        existing.offsetX, existing.offsetY, existingW, existingH
                    )) {
                        collision = true;
                        break;
                    }
                }

                // Verificar colisi√≥n con piedras (c√≠rculo-rect√°ngulo)
                if (!collision) {
                    for (const rock of existingRocksInCell) {
                        if (circleRectOverlap(rock.offsetX, rock.offsetY, rock.radius, newX, newY, HOUSE_WIDTH, HOUSE_HEIGHT)) {
                            collision = true;
                            break;
                        }
                    }
                }

                // Verificar colisi√≥n con √°rboles (c√≠rculo-rect√°ngulo, usando copa)
                if (!collision) {
                    for (const tree of existingTreesInCell) {
                        const crownRadius = tree.radius * 2.5;
                        if (circleRectOverlap(tree.offsetX, tree.offsetY, crownRadius, newX, newY, HOUSE_WIDTH, HOUSE_HEIGHT)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    return { offsetX: newX, offsetY: newY, width: HOUSE_WIDTH, height: HOUSE_HEIGHT };
                }
            }

            return null; // No se pudo colocar sin colisi√≥n
        }

        function generateHouses() {
            const minHeight = parseFloat(document.getElementById('minHeight').value);
            const maxHeight = parseFloat(document.getElementById('maxHeight').value);
            const roadImportance = parseInt(document.getElementById('roadImportance').value) / 100;
            const neighborImportance = parseInt(document.getElementById('neighborImportance').value) / 100;
            const waterImportance = parseInt(document.getElementById('waterImportance').value) / 100;
            const searchRadius = parseInt(document.getElementById('searchRadius').value);
            const baseProbability = parseInt(document.getElementById('houseProbability').value) / 100;
            const maxHousesPerCell = parseInt(document.getElementById('maxHousesPerCell').value);

            if (!grid || grid.length === 0) {
                showInfo('Primero genera un terreno.');
                return;
            }

            // Verificar si hay carreteras para calcular bonus
            const hasRoads = roads.length > 0;

            const newHouses = [];
            let totalHouses = 0;
            let cellsWithHouses = new Set();

            // Recorrer todas las celdas
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];

                    // Verificar si la celda es v√°lida para casas
                    if (!cell.isPassable) continue;
                    if (cell.noise < minHeight || cell.noise > maxHeight) continue;
                    if (cell.roadIds.length > 0) continue; // No casas sobre carreteras

                    // Verificar l√≠mite de casas por celda
                    const currentHouseCount = cell.houses.length;
                    if (currentHouseCount >= maxHousesPerCell) continue;

                    // Empezar con probabilidad base
                    let probability = baseProbability;

                    // Calcular la suma total de importancias para normalizar
                    const totalImportance = roadImportance + neighborImportance + waterImportance;

                    if (totalImportance > 0) {
                        // Bonus por cercan√≠a a carreteras (importance/d¬≤)
                        // Si hay carreteras y la importancia es alta, casas cerca de carreteras tienen m√°s probabilidad
                        if (hasRoads && roadImportance > 0) {
                            const roadBonus = calculateProximityBonus(x, y, searchRadius, roadImportance, (nx, ny) => {
                                return grid[ny][nx].roadIds.length > 0;
                            });
                            probability += roadBonus;
                        }

                        // Bonus por cercan√≠a a agua (importance/d¬≤)
                        if (waterImportance > 0) {
                            const waterBonus = calculateProximityBonus(x, y, searchRadius, waterImportance, (nx, ny) => {
                                return grid[ny][nx].isWater;
                            });
                            probability += waterBonus;
                        }

                        // Bonus por cercan√≠a a vecinos/casas existentes (importance/d¬≤)
                        if (neighborImportance > 0) {
                            const neighborBonus = calculateProximityBonus(x, y, searchRadius, neighborImportance, (nx, ny) => {
                                return grid[ny][nx].houses.length > 0;
                            });
                            probability += neighborBonus;
                        }
                    }

                    // Clamp probabilidad entre 0 y 1
                    probability = Math.max(0, Math.min(1, probability));

                    // Verificar si se genera casa
                    if (Math.random() > probability) continue;

                    // Determinar cantidad de casas a agregar (sin exceder el m√°ximo)
                    const maxToAdd = maxHousesPerCell - currentHouseCount;
                    const numHousesToAdd = Math.min(
                        Math.floor(Math.random() * maxHousesPerCell) + 1,
                        maxToAdd
                    );

                    // Obtener elementos existentes en esta celda
                    const existingHousesInCell = [
                        ...cell.houses,
                        ...newHouses.filter(h => h.cellX === x && h.cellY === y)
                    ];
                    const existingRocksInCell = cell.rocks;
                    const existingTreesInCell = cell.trees;

                    // Intentar colocar cada casa con detecci√≥n de colisiones
                    for (let i = 0; i < numHousesToAdd; i++) {
                        const allHousesInCell = [
                            ...existingHousesInCell,
                            ...newHouses.filter(h => h.cellX === x && h.cellY === y)
                        ];

                        const housePos = tryPlaceHouse(x, y, allHousesInCell, existingRocksInCell, existingTreesInCell);

                        if (housePos) {
                            newHouses.push({
                                cellX: x,
                                cellY: y,
                                ...housePos
                            });
                            totalHouses++;
                            cellsWithHouses.add(`${x},${y}`);
                        }
                    }
                }
            }

            if (newHouses.length === 0) {
                showInfo('No se generaron casas. Intenta aumentar la probabilidad o ajustar los filtros.');
                return;
            }

            const houseGroup = {
                id: houseGroupIdCounter++,
                name: `Grupo ${houseGroupIdCounter - 1}`,
                visible: true,
                count: totalHouses,
                params: { minHeight, maxHeight, roadImportance, neighborImportance, waterImportance, searchRadius, baseProbability, maxHousesPerCell }
            };

            houses.push(houseGroup);

            newHouses.forEach(h => {
                grid[h.cellY][h.cellX].houses.push({
                    groupId: houseGroup.id,
                    offsetX: h.offsetX,
                    offsetY: h.offsetY,
                    width: h.width,
                    height: h.height
                });
            });

            updateUI();
            drawGrid();
            showInfo(`Generadas ${totalHouses} casas en ${cellsWithHouses.size} celdas.`);
        }

        function deleteHouseGroup(groupId) {
            const groupIndex = houses.findIndex(g => g.id === groupId);
            if (groupIndex === -1) return;

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].houses = grid[y][x].houses.filter(h => h.groupId !== groupId);
                }
            }

            houses.splice(groupIndex, 1);
            updateUI();
            drawGrid();
        }

        function toggleHouseGroupVisibility(groupId) {
            const group = houses.find(g => g.id === groupId);
            if (group) {
                group.visible = !group.visible;
                updateUI();
                drawGrid();
            }
        }

        function toggleAllHouses(visible) {
            houses.forEach(g => g.visible = visible);
            updateUI();
            drawGrid();
        }

        function clearAllHouses() {
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].houses = [];
                }
            }
            houses = [];
            houseGroupIdCounter = 1;
            updateUI();
            drawGrid();
            showInfo('Todas las casas han sido eliminadas.');
        }

        function clearAll() {
            roads = [];
            houses = [];
            rocks = [];
            trees = [];
            roadIdCounter = 1;
            houseGroupIdCounter = 1;
            rockGroupIdCounter = 1;
            treeGroupIdCounter = 1;
            selectedCells = [];

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].roadIds = [];
                    grid[y][x].houses = [];
                    grid[y][x].rocks = [];
                    grid[y][x].trees = [];
                }
            }

            updateUI();
            drawGrid();
            showInfo('Todo limpiado.');
        }

        // ============== PIEDRAS ==============
        // Constantes para piedras
        const ROCK_MIN_RADIUS_DEFAULT = 0.08;
        const ROCK_MAX_RADIUS_DEFAULT = 0.25;

        // Verifica si dos c√≠rculos se superponen
        function circlesOverlap(x1, y1, r1, x2, y2, r2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (r1 + r2);
        }

        // Calcula probabilidad de piedra seg√∫n altura del terreno
        // Monta√±as (0.6-0.75): alta probabilidad
        // Agua (<0.3): 0%
        // Monta√±as altas (>0.75): 0%
        function getRockHeightProbability(noise) {
            if (noise < 0.3) return 0; // Agua - no piedras
            if (noise > 0.75) return 0; // Monta√±as altas - no piedras
            if (noise >= 0.6 && noise <= 0.75) {
                // Monta√±as - alta probabilidad (80-100%)
                return 0.8 + (noise - 0.6) * 1.33;
            }
            if (noise >= 0.5 && noise < 0.6) {
                // Cerca de monta√±as - probabilidad media (40-80%)
                return 0.4 + (noise - 0.5) * 4;
            }
            // Tierras bajas - probabilidad baja (10-40%)
            return 0.1 + (noise - 0.3) * 1.5;
        }

        // Intenta colocar una piedra sin colisi√≥n
        // Verifica colisiones con otras piedras, casas y √°rboles
        function tryPlaceRock(cellX, cellY, existingRocksInCell, existingHousesInCell = [], existingTreesInCell = [], minRadius, maxRadius, maxAttempts = 20) {
            const radius = minRadius + Math.random() * (maxRadius - minRadius);
            const margin = radius + 0.02;
            const availableSpace = 1 - 2 * margin;

            if (availableSpace <= 0) return null;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const newX = margin + Math.random() * availableSpace;
                const newY = margin + Math.random() * availableSpace;

                let collision = false;

                // Verificar colisi√≥n con piedras existentes
                for (const existing of existingRocksInCell) {
                    if (circlesOverlap(newX, newY, radius, existing.offsetX, existing.offsetY, existing.radius)) {
                        collision = true;
                        break;
                    }
                }

                // Verificar colisi√≥n con casas (c√≠rculo-rect√°ngulo)
                if (!collision) {
                    for (const house of existingHousesInCell) {
                        const houseW = house.width || HOUSE_WIDTH;
                        const houseH = house.height || HOUSE_HEIGHT;
                        if (circleRectOverlap(newX, newY, radius, house.offsetX, house.offsetY, houseW, houseH)) {
                            collision = true;
                            break;
                        }
                    }
                }

                // Verificar colisi√≥n con √°rboles (c√≠rculo-c√≠rculo, usando copa)
                if (!collision) {
                    for (const tree of existingTreesInCell) {
                        const crownRadius = tree.radius * 2.5;
                        if (circlesOverlap(newX, newY, radius, tree.offsetX, tree.offsetY, crownRadius)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    // Generar shade aleatorio para consistencia visual
                    const shade = 80 + Math.floor(Math.random() * 40);
                    return { offsetX: newX, offsetY: newY, radius: radius, shade: shade };
                }
            }

            return null;
        }

        function generateRocks() {
            const baseProbability = parseInt(document.getElementById('rockProbability').value) / 100;
            const maxRocksPerCell = parseInt(document.getElementById('maxRocksPerCell').value);
            const minRadius = parseFloat(document.getElementById('rockMinRadius').value);
            const maxRadius = parseFloat(document.getElementById('rockMaxRadius').value);

            if (!grid || grid.length === 0) {
                showInfo('Primero genera un terreno.');
                return;
            }

            const newRocks = [];
            let totalRocks = 0;
            let cellsWithRocks = new Set();

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];

                    // No piedras en agua, monta√±as altas, carreteras, o celdas con casas
                    if (cell.isWater) continue;
                    if (cell.noise > 0.75) continue; // Monta√±as altas
                    if (cell.roadIds.length > 0) continue;
                    if (cell.houses.length > 0) continue;

                    // Verificar l√≠mite de piedras por celda
                    const currentRockCount = cell.rocks.length;
                    if (currentRockCount >= maxRocksPerCell) continue;

                    // Calcular probabilidad basada en altura
                    const heightProb = getRockHeightProbability(cell.noise);
                    const probability = baseProbability * heightProb;

                    if (Math.random() > probability) continue;

                    // Determinar cantidad de piedras a agregar
                    const maxToAdd = maxRocksPerCell - currentRockCount;
                    const numRocksToAdd = Math.min(
                        Math.floor(Math.random() * maxRocksPerCell) + 1,
                        maxToAdd
                    );

                    // Obtener elementos existentes
                    const existingRocksInCell = [
                        ...cell.rocks,
                        ...newRocks.filter(r => r.cellX === x && r.cellY === y)
                    ];
                    const existingHousesInCell = cell.houses;
                    const existingTreesInCell = cell.trees;

                    for (let i = 0; i < numRocksToAdd; i++) {
                        const allRocksInCell = [
                            ...existingRocksInCell,
                            ...newRocks.filter(r => r.cellX === x && r.cellY === y)
                        ];

                        const rockPos = tryPlaceRock(x, y, allRocksInCell, existingHousesInCell, existingTreesInCell, minRadius, maxRadius);

                        if (rockPos) {
                            newRocks.push({
                                cellX: x,
                                cellY: y,
                                ...rockPos
                            });
                            totalRocks++;
                            cellsWithRocks.add(`${x},${y}`);
                        }
                    }
                }
            }

            if (newRocks.length === 0) {
                showInfo('No se generaron piedras. Intenta aumentar la probabilidad.');
                return;
            }

            const rockGroup = {
                id: rockGroupIdCounter++,
                name: `Piedras ${rockGroupIdCounter - 1}`,
                visible: true,
                count: totalRocks
            };

            rocks.push(rockGroup);

            newRocks.forEach(r => {
                grid[r.cellY][r.cellX].rocks.push({
                    groupId: rockGroup.id,
                    offsetX: r.offsetX,
                    offsetY: r.offsetY,
                    radius: r.radius,
                    shade: r.shade
                });
            });

            updateUI();
            drawGrid();
            showInfo(`Generadas ${totalRocks} piedras en ${cellsWithRocks.size} celdas.`);
        }

        function deleteRockGroup(groupId) {
            const groupIndex = rocks.findIndex(g => g.id === groupId);
            if (groupIndex === -1) return;

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].rocks = grid[y][x].rocks.filter(r => r.groupId !== groupId);
                }
            }

            rocks.splice(groupIndex, 1);
            updateUI();
            drawGrid();
        }

        function toggleRockGroupVisibility(groupId) {
            const group = rocks.find(g => g.id === groupId);
            if (group) {
                group.visible = !group.visible;
                updateUI();
                drawGrid();
            }
        }

        function toggleAllRocks(visible) {
            rocks.forEach(g => g.visible = visible);
            updateUI();
            drawGrid();
        }

        function clearAllRocks() {
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].rocks = [];
                }
            }
            rocks = [];
            rockGroupIdCounter = 1;
            updateUI();
            drawGrid();
            showInfo('Todas las piedras han sido eliminadas.');
        }

        // ============== √ÅRBOLES ==============
        // Constantes para √°rboles
        const TREE_MIN_RADIUS_DEFAULT = 0.05;
        const TREE_MAX_RADIUS_DEFAULT = 0.12;

        // Verifica colisi√≥n c√≠rculo-rect√°ngulo
        function circleRectOverlap(cx, cy, radius, rx, ry, rw, rh) {
            // Encontrar el punto m√°s cercano del rect√°ngulo al centro del c√≠rculo
            const closestX = Math.max(rx, Math.min(cx, rx + rw));
            const closestY = Math.max(ry, Math.min(cy, ry + rh));

            // Calcular distancia del centro del c√≠rculo al punto m√°s cercano
            const dx = cx - closestX;
            const dy = cy - closestY;
            const distanceSquared = dx * dx + dy * dy;

            return distanceSquared < (radius * radius);
        }

        // Calcula probabilidad de √°rbol seg√∫n altura del terreno
        // Altura ideal: 20% (0.2), menos o m√°s altura reduce probabilidad
        function getTreeHeightProbability(noise) {
            if (noise < 0.25) return 0; // Agua y zonas muy bajas - no √°rboles
            if (noise > 0.75) return 0; // Monta√±as altas - no √°rboles

            // Altura ideal es 0.35 (equivalente a "20%" del rango √∫til 0.25-0.75)
            const idealHeight = 0.35;
            const deviation = Math.abs(noise - idealHeight);

            // Probabilidad m√°xima en altura ideal, decrece linealmente
            // A 0.35: 100%, a los extremos (0.25 o 0.75): ~10%
            const maxDeviation = 0.4; // m√°xima desviaci√≥n posible
            const probability = Math.max(0.1, 1 - (deviation / maxDeviation) * 0.9);

            return probability;
        }

        // Cuenta casas cercanas a una celda
        function countNearbyHouses(x, y, radius) {
            let count = 0;
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                        count += grid[ny][nx].houses.length;
                    }
                }
            }
            return count;
        }

        // Intenta colocar un √°rbol sin colisi√≥n con casas, piedras y otros √°rboles
        function tryPlaceTree(cellX, cellY, existingTreesInCell, existingHousesInCell, existingRocksInCell = [], minRadius, maxRadius, maxAttempts = 30) {
            const radius = minRadius + Math.random() * (maxRadius - minRadius);
            const crownRadius = radius * 2.5; // La copa es m√°s grande
            const margin = crownRadius + 0.02;
            const availableSpace = 1 - 2 * margin;

            if (availableSpace <= 0) return null;

            for (let attempt = 0; attempt < maxAttempts; attempt++) {
                const newX = margin + Math.random() * availableSpace;
                const newY = margin + Math.random() * availableSpace;

                let collision = false;

                // Verificar colisi√≥n con otros √°rboles
                for (const existing of existingTreesInCell) {
                    const existingCrown = existing.radius * 2.5;
                    if (circlesOverlap(newX, newY, crownRadius, existing.offsetX, existing.offsetY, existingCrown)) {
                        collision = true;
                        break;
                    }
                }

                // Verificar colisi√≥n con casas (c√≠rculo-rect√°ngulo)
                if (!collision) {
                    for (const house of existingHousesInCell) {
                        const houseW = house.width || HOUSE_WIDTH;
                        const houseH = house.height || HOUSE_HEIGHT;
                        if (circleRectOverlap(newX, newY, crownRadius, house.offsetX, house.offsetY, houseW, houseH)) {
                            collision = true;
                            break;
                        }
                    }
                }

                // Verificar colisi√≥n con piedras (c√≠rculo-c√≠rculo)
                if (!collision) {
                    for (const rock of existingRocksInCell) {
                        if (circlesOverlap(newX, newY, crownRadius, rock.offsetX, rock.offsetY, rock.radius)) {
                            collision = true;
                            break;
                        }
                    }
                }

                if (!collision) {
                    return { offsetX: newX, offsetY: newY, radius: radius };
                }
            }

            return null;
        }

        function generateTrees() {
            const baseProbability = parseInt(document.getElementById('treeProbability').value) / 100;
            const maxTreesPerCell = parseInt(document.getElementById('maxTreesPerCell').value);
            const minRadius = parseFloat(document.getElementById('treeMinRadius').value);
            const maxRadius = parseFloat(document.getElementById('treeMaxRadius').value);
            const casePenalty = parseInt(document.getElementById('treeCasePenalty').value) / 100;
            const searchRadius = parseInt(document.getElementById('treeSearchRadius').value);

            if (!grid || grid.length === 0) {
                showInfo('Primero genera un terreno.');
                return;
            }

            const newTrees = [];
            let totalTrees = 0;
            let cellsWithTrees = new Set();

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];

                    // No √°rboles en agua, monta√±as altas, o carreteras
                    if (cell.isWater) continue;
                    if (cell.noise > 0.75) continue; // Monta√±as altas
                    if (cell.noise < 0.25) continue; // Zonas muy bajas
                    if (cell.roadIds.length > 0) continue;

                    // Verificar l√≠mite de √°rboles por celda
                    const currentTreeCount = cell.trees.length;
                    if (currentTreeCount >= maxTreesPerCell) continue;

                    // Calcular probabilidad basada en altura
                    const heightProb = getTreeHeightProbability(cell.noise);

                    // Penalizaci√≥n por casas cercanas
                    const nearbyHouses = countNearbyHouses(x, y, searchRadius);
                    const housePenalty = Math.max(0, 1 - nearbyHouses * casePenalty);

                    const probability = baseProbability * heightProb * housePenalty;

                    if (Math.random() > probability) continue;

                    // Determinar cantidad de √°rboles a agregar
                    const maxToAdd = maxTreesPerCell - currentTreeCount;
                    const numTreesToAdd = Math.min(
                        Math.floor(Math.random() * maxTreesPerCell) + 1,
                        maxToAdd
                    );

                    // Obtener elementos existentes
                    const existingTreesInCell = [
                        ...cell.trees,
                        ...newTrees.filter(t => t.cellX === x && t.cellY === y)
                    ];
                    const existingHousesInCell = cell.houses;
                    const existingRocksInCell = cell.rocks;

                    for (let i = 0; i < numTreesToAdd; i++) {
                        const allTreesInCell = [
                            ...existingTreesInCell,
                            ...newTrees.filter(t => t.cellX === x && t.cellY === y)
                        ];

                        const treePos = tryPlaceTree(x, y, allTreesInCell, existingHousesInCell, existingRocksInCell, minRadius, maxRadius);

                        if (treePos) {
                            newTrees.push({
                                cellX: x,
                                cellY: y,
                                ...treePos
                            });
                            totalTrees++;
                            cellsWithTrees.add(`${x},${y}`);
                        }
                    }
                }
            }

            if (newTrees.length === 0) {
                showInfo('No se generaron √°rboles. Intenta aumentar la probabilidad o reducir penalizaci√≥n.');
                return;
            }

            const treeGroup = {
                id: treeGroupIdCounter++,
                name: `√Årboles ${treeGroupIdCounter - 1}`,
                visible: true,
                count: totalTrees
            };

            trees.push(treeGroup);

            newTrees.forEach(t => {
                grid[t.cellY][t.cellX].trees.push({
                    groupId: treeGroup.id,
                    offsetX: t.offsetX,
                    offsetY: t.offsetY,
                    radius: t.radius
                });
            });

            updateUI();
            drawGrid();
            showInfo(`Generados ${totalTrees} √°rboles en ${cellsWithTrees.size} celdas.`);
        }

        function deleteTreeGroup(groupId) {
            const groupIndex = trees.findIndex(g => g.id === groupId);
            if (groupIndex === -1) return;

            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].trees = grid[y][x].trees.filter(t => t.groupId !== groupId);
                }
            }

            trees.splice(groupIndex, 1);
            updateUI();
            drawGrid();
        }

        function toggleTreeGroupVisibility(groupId) {
            const group = trees.find(g => g.id === groupId);
            if (group) {
                group.visible = !group.visible;
                updateUI();
                drawGrid();
            }
        }

        function toggleAllTrees(visible) {
            trees.forEach(g => g.visible = visible);
            updateUI();
            drawGrid();
        }

        function clearAllTrees() {
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].trees = [];
                }
            }
            trees = [];
            treeGroupIdCounter = 1;
            updateUI();
            drawGrid();
            showInfo('Todos los √°rboles han sido eliminados.');
        }

        // ============== DEFINICI√ìN DE MATERIALES ==============
        function addMaterialDefinition(minAlt = 0, maxAlt = 0.1, materialNum = 1, name = '', color = '#ffffff') {
            const id = materialIdCounter++;
            materialDefinitions.push({
                id: id,
                minAltitude: minAlt,
                maxAltitude: maxAlt,
                materialNumber: materialNum,
                name: name || `Material ${materialNum}`,
                color: color
            });
            updateMaterialsList();
            updateLegend();
        }

        function deleteMaterialDefinition(id) {
            materialDefinitions = materialDefinitions.filter(m => m.id !== id);
            updateMaterialsList();
            drawGrid(); // Redibujar el mapa
        }

        function updateMaterialsList() {
            const container = document.getElementById('materialsList');
            if (materialDefinitions.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 11px; text-align: center; padding: 8px;">No hay materiales definidos</div>';
                return;
            }

            // Sort by minAltitude for display
            const sortedMaterials = [...materialDefinitions].sort((a, b) => a.minAltitude - b.minAltitude);

            container.innerHTML = sortedMaterials.map(mat => `
                <div class="material-item">
                    <input type="color" value="${mat.color}" 
                           onchange="updateMaterialColor(${mat.id}, this.value)" 
                           title="Color del material">
                    <input type="text" value="${mat.name}" 
                           onchange="updateMaterialName(${mat.id}, this.value)" 
                           placeholder="Nombre"
                           title="Nombre del material">
                    <input type="number" value="${mat.minAltitude}" 
                           onchange="updateMaterialMin(${mat.id}, this.value)" 
                           min="0" max="1" step="0.01"
                           title="Altitud m√≠nima">
                    <span style="color: #666;">-</span>
                    <input type="number" value="${mat.maxAltitude}" 
                           onchange="updateMaterialMax(${mat.id}, this.value)" 
                           min="0" max="1" step="0.01"
                           title="Altitud m√°xima">
                    <span style="color: #666;">=</span>
                    <input type="number" value="${mat.materialNumber}" 
                           onchange="updateMaterialNumber(${mat.id}, this.value)" 
                           min="0" max="255"
                           title="N√∫mero de material">
                    <button class="delete-btn small danger" onclick="deleteMaterialDefinition(${mat.id})" title="Eliminar">üóëÔ∏è</button>
                </div>
            `).join('');

            updateLegend();
        }

        function updateLegend() {
            const container = document.getElementById('legendContainer');

            // Sort materials by minAltitude
            const sortedMaterials = [...materialDefinitions].sort((a, b) => a.minAltitude - b.minAltitude);

            // Generate material legend items
            const materialItems = sortedMaterials.map(mat => `
                <div class="legend-item">
                    <div class="color-box" style="background: ${mat.color};"></div>
                    <span>${mat.name}</span>
                </div>
            `).join('');

            // Add entity items (houses, rocks, trees)
            const entityItems = `
                <div class="legend-item">
                    <div class="color-box" style="background: #FFD700;"></div>
                    <span>Carretera</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #e74c3c;"></div>
                    <span>Casa</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #6b6b6b; border-radius: 50%;"></div>
                    <span>Piedra</span>
                </div>
                <div class="legend-item">
                    <div class="color-box" style="background: #228B22; border-radius: 50%;"></div>
                    <span>√Årbol</span>
                </div>
            `;

            container.innerHTML = materialItems + entityItems;
        }

        function updateMaterialName(id, value) {
            const mat = materialDefinitions.find(m => m.id === id);
            if (mat) {
                mat.name = value;
                updateLegend();
            }
        }

        function updateMaterialMin(id, value) {
            const mat = materialDefinitions.find(m => m.id === id);
            if (mat) {
                mat.minAltitude = parseFloat(value);
                drawGrid(); // Redibujar el mapa con los nuevos rangos
            }
        }

        function updateMaterialMax(id, value) {
            const mat = materialDefinitions.find(m => m.id === id);
            if (mat) {
                mat.maxAltitude = parseFloat(value);
                drawGrid(); // Redibujar el mapa con los nuevos rangos
            }
        }

        function updateMaterialNumber(id, value) {
            const mat = materialDefinitions.find(m => m.id === id);
            if (mat) mat.materialNumber = parseInt(value);
        }

        function updateMaterialColor(id, value) {
            const mat = materialDefinitions.find(m => m.id === id);
            if (mat) {
                mat.color = value;
                updateLegend(); // Actualizar leyenda con el nuevo color
                drawGrid(); // Redibujar el mapa con el nuevo color
            }
        }

        function toggleRoadMaterial() {
            const checkbox = document.getElementById('roadsAsMaterial');
            const input = document.getElementById('roadMaterialInput');
            input.style.display = checkbox.checked ? 'block' : 'none';
        }

        function initializeDefaultMaterials() {
            // Default material definitions based on current terrain colors
            // These match the getTerrainColor function's original logic
            materialDefinitions = [];
            materialIdCounter = 1;
            addMaterialDefinition(0, 0.25, 1, 'Agua Profunda', '#0a1f2e');
            addMaterialDefinition(0.25, 0.3, 2, 'Agua', '#1a4d2e');
            addMaterialDefinition(0.3, 0.6, 3, 'Tierra', '#8B4513');
            addMaterialDefinition(0.6, 0.75, 4, 'Monta√±a', '#90EE90');
            addMaterialDefinition(0.75, 1.0, 5, 'Monta√±a Alta', '#4a4a4a');
        }

        // Generate materials array based on definitions
        function generateMaterialsArray() {
            if (!grid || grid.length === 0) return [];

            const roadsAsMaterial = document.getElementById('roadsAsMaterial').checked;
            const roadMaterialNum = parseInt(document.getElementById('roadMaterialNumber').value) || 99;

            const materialsArray = [];

            for (let y = 0; y < grid.length; y++) {
                const row = [];
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];

                    // Check if cell has road and roads should override material
                    if (roadsAsMaterial && cell.roadIds.length > 0) {
                        row.push(roadMaterialNum);
                    } else {
                        // Find matching material based on altitude
                        const altitude = cell.noise;
                        let materialNum = 0; // Default material if no match

                        for (const mat of materialDefinitions) {
                            if (altitude >= mat.minAltitude && altitude < mat.maxAltitude) {
                                materialNum = mat.materialNumber;
                                break;
                            }
                        }

                        row.push(materialNum);
                    }
                }
                materialsArray.push(row);
            }

            return materialsArray;
        }

        // ============== EXPORTAR DATOS ==============
        function exportMapData() {
            if (!grid || grid.length === 0) {
                showInfo('No hay mapa para exportar. Genera un terreno primero.');
                return;
            }

            const exportType = document.getElementById('exportType').value;

            // 1. Par√°metros de generaci√≥n
            const parameters = {
                width: parseInt(document.getElementById('width').value),
                height: parseInt(document.getElementById('height').value),
                cellSize: cellSize,
                scale: parseFloat(document.getElementById('scale').value),
                octaves: parseInt(document.getElementById('octaves').value),
                persistence: parseFloat(document.getElementById('persistence').value),
                lacunarity: parseFloat(document.getElementById('lacunarity').value),
                minPassable: MIN_PASSABLE,
                maxPassable: MAX_PASSABLE,
                waterThreshold: WATER_THRESHOLD
            };

            // 2. Grid como array de arrays con altitude y passable
            const gridData = [];
            for (let y = 0; y < grid.length; y++) {
                const row = [];
                for (let x = 0; x < grid[y].length; x++) {
                    const cell = grid[y][x];
                    row.push({
                        altitude: parseFloat(cell.noise.toFixed(4)),
                        passable: cell.isPassable,
                        isWater: cell.isWater,
                        hasRoad: cell.roadIds.length > 0
                    });
                }
                gridData.push(row);
            }

            // 3. Entidades
            // Casas
            const housesData = [];
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].houses.forEach(house => {
                        const worldX = (x + house.offsetX) * cellSize;
                        const worldY = (y + house.offsetY) * cellSize;
                        housesData.push({
                            cellX: x,
                            cellY: y,
                            offsetX: parseFloat(house.offsetX.toFixed(4)),
                            offsetY: parseFloat(house.offsetY.toFixed(4)),
                            width: parseFloat((house.width || HOUSE_WIDTH).toFixed(4)),
                            height: parseFloat((house.height || HOUSE_HEIGHT).toFixed(4)),
                            worldX: parseFloat(worldX.toFixed(2)),
                            worldY: parseFloat(worldY.toFixed(2))
                        });
                    });
                }
            }

            // √Årboles (con radius y height derivada)
            const treesData = [];
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].trees.forEach(tree => {
                        const crownRadius = tree.radius * 2.5;
                        // Altura del √°rbol: proporcional al radio (aproximadamente 4x el radio de copa)
                        const treeHeight = crownRadius * 4;
                        const worldX = (x + tree.offsetX) * cellSize;
                        const worldY = (y + tree.offsetY) * cellSize;
                        treesData.push({
                            cellX: x,
                            cellY: y,
                            offsetX: parseFloat(tree.offsetX.toFixed(4)),
                            offsetY: parseFloat(tree.offsetY.toFixed(4)),
                            radius: parseFloat(tree.radius.toFixed(4)),
                            crownRadius: parseFloat(crownRadius.toFixed(4)),
                            height: parseFloat(treeHeight.toFixed(4)),
                            worldX: parseFloat(worldX.toFixed(2)),
                            worldY: parseFloat(worldY.toFixed(2))
                        });
                    });
                }
            }

            // Piedras
            const rocksData = [];
            for (let y = 0; y < grid.length; y++) {
                for (let x = 0; x < grid[y].length; x++) {
                    grid[y][x].rocks.forEach(rock => {
                        const worldX = (x + rock.offsetX) * cellSize;
                        const worldY = (y + rock.offsetY) * cellSize;
                        rocksData.push({
                            cellX: x,
                            cellY: y,
                            offsetX: parseFloat(rock.offsetX.toFixed(4)),
                            offsetY: parseFloat(rock.offsetY.toFixed(4)),
                            radius: parseFloat(rock.radius.toFixed(4)),
                            worldX: parseFloat(worldX.toFixed(2)),
                            worldY: parseFloat(worldY.toFixed(2))
                        });
                    });
                }
            }

            // Carreteras
            const roadsData = roads.map(road => ({
                id: road.id,
                name: road.name,
                start: {
                    x: road.start.x,
                    y: road.start.y,
                    worldX: road.start.x * cellSize,
                    worldY: road.start.y * cellSize
                },
                end: {
                    x: road.end.x,
                    y: road.end.y,
                    worldX: road.end.x * cellSize,
                    worldY: road.end.y * cellSize
                },
                cells: road.cells.map(c => ({
                    x: c.x,
                    y: c.y,
                    worldX: c.x * cellSize,
                    worldY: c.y * cellSize
                }))
            }));

            // Generate materials array
            const materialsArray = generateMaterialsArray();

            // Construir objeto final seg√∫n el tipo de exportaci√≥n
            let mapData;
            let filename;

            if (exportType === 'materials') {
                // Solo exportar array de materiales
                mapData = {
                    materials: materialsArray,
                    materialDefinitions: materialDefinitions.map(mat => ({
                        name: mat.name,
                        minAltitude: mat.minAltitude,
                        maxAltitude: mat.maxAltitude,
                        materialNumber: mat.materialNumber,
                        color: mat.color
                    })),
                    materialsConfig: {
                        roadsAsMaterial: document.getElementById('roadsAsMaterial').checked,
                        roadMaterialNumber: parseInt(document.getElementById('roadMaterialNumber').value) || 99
                    },
                    metadata: {
                        exportDate: new Date().toISOString(),
                        gridWidth: grid[0].length,
                        gridHeight: grid.length
                    }
                };
                filename = `materials_${parameters.width}x${parameters.height}_${Date.now()}.json`;
            } else {
                // Exportaci√≥n completa
                mapData = {
                    parameters: parameters,
                    grid: gridData,
                    materials: materialsArray,
                    materialDefinitions: materialDefinitions.map(mat => ({
                        name: mat.name,
                        minAltitude: mat.minAltitude,
                        maxAltitude: mat.maxAltitude,
                        materialNumber: mat.materialNumber,
                        color: mat.color
                    })),
                    materialsConfig: {
                        roadsAsMaterial: document.getElementById('roadsAsMaterial').checked,
                        roadMaterialNumber: parseInt(document.getElementById('roadMaterialNumber').value) || 99
                    },
                    entities: {
                        houses: housesData,
                        trees: treesData,
                        rocks: rocksData,
                        roads: roadsData
                    },
                    metadata: {
                        exportDate: new Date().toISOString(),
                        gridWidth: grid[0].length,
                        gridHeight: grid.length,
                        totalHouses: housesData.length,
                        totalTrees: treesData.length,
                        totalRocks: rocksData.length,
                        totalRoads: roadsData.length
                    }
                };
                filename = `map_${parameters.width}x${parameters.height}_${Date.now()}.json`;
            }

            // Descargar como JSON
            const jsonString = JSON.stringify(mapData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            if (exportType === 'materials') {
                showInfo(`Materiales exportados: ${grid[0].length}x${grid.length} array.`);
            } else {
                showInfo(`Mapa exportado: ${housesData.length} casas, ${treesData.length} √°rboles, ${rocksData.length} piedras, ${roadsData.length} carreteras. Materiales: ${grid[0].length}x${grid.length} array.`);
            }
        }

        // ============== A* PATHFINDING ==============
        function aStar(start, end, maxHousesToDestroy = null) {
            // Obtener el valor del input si no se especifica
            if (maxHousesToDestroy === null) {
                maxHousesToDestroy = parseInt(document.getElementById('maxHousesToDestroy').value) || 0;
            }

            const openSet = [start];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            const key = (p) => `${p.x},${p.y}`;
            gScore.set(key(start), 0);
            fScore.set(key(start), heuristic(start, end));

            while (openSet.length > 0) {
                openSet.sort((a, b) => fScore.get(key(a)) - fScore.get(key(b)));
                const current = openSet.shift();

                if (current.x === end.x && current.y === end.y) {
                    return reconstructPath(cameFrom, current);
                }

                const neighbors = getNeighbors(current, maxHousesToDestroy);
                for (let neighbor of neighbors) {
                    const tentativeGScore = gScore.get(key(current)) + cost(current, neighbor);

                    if (!gScore.has(key(neighbor)) || tentativeGScore < gScore.get(key(neighbor))) {
                        cameFrom.set(key(neighbor), current);
                        gScore.set(key(neighbor), tentativeGScore);
                        fScore.set(key(neighbor), tentativeGScore + heuristic(neighbor, end));

                        if (!openSet.some(p => p.x === neighbor.x && p.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }

            return [];
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
        }

        function cost(a, b) {
            if (!grid || !grid[a.y] || !grid[b.y]) return 1;
            const heightDiff = Math.abs(grid[a.y][a.x].noise - grid[b.y][b.x].noise);
            // Costo base + diferencia de altura + costo por destruir casas
            const houseCost = getHouseDestroyCost(b.x, b.y);
            return 1 + heightDiff * 5 + houseCost;
        }

        function getNeighbors(cell, maxHousesToDestroy) {
            if (!grid || grid.length === 0) return [];

            const neighbors = [];
            const dirs = [{ x: 0, y: -1 }, { x: 1, y: 0 }, { x: 0, y: 1 }, { x: -1, y: 0 }];

            for (let dir of dirs) {
                const nx = cell.x + dir.x;
                const ny = cell.y + dir.y;
                if (ny >= 0 && ny < grid.length && nx >= 0 && nx < grid[0].length) {
                    // Vecinos que pueden ser carretera (pasables y con casas <= m√°ximo destruible)
                    if (canBeRoad(nx, ny, maxHousesToDestroy)) {
                        neighbors.push({ x: nx, y: ny });
                    }
                }
            }
            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const path = [current];
            const key = (p) => `${p.x},${p.y}`;

            while (cameFrom.has(key(current))) {
                current = cameFrom.get(key(current));
                path.unshift(current);
            }
            return path;
        }

        // Expands a road path to make it wider
        // Width 1 = original path, Width 2+ = adds layers of adjacent passable cells
        function expandRoadPath(path, width, maxHousesToDestroy) {
            if (width <= 1 || path.length === 0) return path;

            const key = (p) => `${p.x},${p.y}`;
            const expandedSet = new Set();
            const expandedPath = [];

            // Add original path cells
            path.forEach(cell => {
                expandedSet.add(key(cell));
                expandedPath.push({ x: cell.x, y: cell.y });
            });

            // Expand in layers
            let currentLayer = [...path];
            const layersToAdd = width - 1;

            for (let layer = 0; layer < layersToAdd; layer++) {
                const nextLayer = [];

                for (const cell of currentLayer) {
                    // Check 4 neighbors (up, down, left, right)
                    const neighbors = [
                        // { x: cell.x, y: cell.y - 1 },
                        { x: cell.x, y: cell.y + 1 },
                        // { x: cell.x - 1, y: cell.y },
                        { x: cell.x + 1, y: cell.y }
                    ];

                    for (const neighbor of neighbors) {
                        const nKey = key(neighbor);

                        // Skip if already in expanded path
                        if (expandedSet.has(nKey)) continue;

                        // Check bounds
                        if (neighbor.y < 0 || neighbor.y >= grid.length) continue;
                        if (neighbor.x < 0 || neighbor.x >= grid[0].length) continue;

                        // Check if cell can be part of road (passable and respects house destruction limit)
                        if (canBeRoad(neighbor.x, neighbor.y, maxHousesToDestroy)) {
                            expandedSet.add(nKey);
                            expandedPath.push({ x: neighbor.x, y: neighbor.y });
                            nextLayer.push(neighbor);
                        }
                    }
                }

                currentLayer = nextLayer;
            }

            return expandedPath;
        }

        // ============== UI ==============
        function updateUI() {
            updateRoadsList();
            updateHousesList();
            updateRocksList();
            updateTreesList();
            updateStats();
        }

        function updateRoadsList() {
            const container = document.getElementById('roadsList');
            if (roads.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 10px;">No hay carreteras</div>';
                return;
            }

            container.innerHTML = roads.map(road => `
                <div class="entity-item">
                    <div class="entity-color" style="background: ${road.color};"></div>
                    <span class="name" title="${road.name}: ${road.cells.length} celdas, ancho ${road.width || 1}">${road.name} (${road.cells.length}) w${road.width || 1}</span>
                    <button class="visibility-btn small ${road.visible ? '' : 'secondary'}" onclick="toggleRoadVisibility(${road.id})">
                        ${road.visible ? 'üëÅÔ∏è' : 'üôà'}
                    </button>
                    <button class="delete-btn small danger" onclick="deleteRoad(${road.id})">üóëÔ∏è</button>
                </div>
            `).join('');
        }

        function updateHousesList() {
            const container = document.getElementById('housesList');
            if (houses.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 10px;">No hay casas</div>';
                return;
            }

            container.innerHTML = houses.map(group => `
                <div class="entity-item">
                    <div class="entity-color" style="background: #e74c3c;"></div>
                    <span class="name" title="${group.name}: ${group.count} casas">${group.name} (${group.count})</span>
                    <button class="visibility-btn small ${group.visible ? '' : 'secondary'}" onclick="toggleHouseGroupVisibility(${group.id})">
                        ${group.visible ? 'üëÅÔ∏è' : 'üôà'}
                    </button>
                    <button class="delete-btn small danger" onclick="deleteHouseGroup(${group.id})">üóëÔ∏è</button>
                </div>
            `).join('');
        }

        function updateRocksList() {
            const container = document.getElementById('rocksList');
            if (rocks.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 10px;">No hay piedras</div>';
                return;
            }

            container.innerHTML = rocks.map(group => `
                <div class="entity-item">
                    <div class="entity-color" style="background: #6b6b6b; border-radius: 50%;"></div>
                    <span class="name" title="${group.name}: ${group.count} piedras">${group.name} (${group.count})</span>
                    <button class="visibility-btn small ${group.visible ? '' : 'secondary'}" onclick="toggleRockGroupVisibility(${group.id})">
                        ${group.visible ? 'üëÅÔ∏è' : 'üôà'}
                    </button>
                    <button class="delete-btn small danger" onclick="deleteRockGroup(${group.id})">üóëÔ∏è</button>
                </div>
            `).join('');
        }

        function updateTreesList() {
            const container = document.getElementById('treesList');
            if (trees.length === 0) {
                container.innerHTML = '<div style="color: #666; font-size: 12px; text-align: center; padding: 10px;">No hay √°rboles</div>';
                return;
            }

            container.innerHTML = trees.map(group => `
                <div class="entity-item">
                    <div class="entity-color" style="background: #228B22; border-radius: 50%;"></div>
                    <span class="name" title="${group.name}: ${group.count} √°rboles">${group.name} (${group.count})</span>
                    <button class="visibility-btn small ${group.visible ? '' : 'secondary'}" onclick="toggleTreeGroupVisibility(${group.id})">
                        ${group.visible ? 'üëÅÔ∏è' : 'üôà'}
                    </button>
                    <button class="delete-btn small danger" onclick="deleteTreeGroup(${group.id})">üóëÔ∏è</button>
                </div>
            `).join('');
        }

        function updateStats() {
            const totalRoadCells = roads.reduce((sum, r) => sum + r.cells.length, 0);
            const totalHouses = houses.reduce((sum, g) => sum + g.count, 0);
            const totalRocks = rocks.reduce((sum, g) => sum + g.count, 0);
            const totalTrees = trees.reduce((sum, g) => sum + g.count, 0);
            const totalCells = grid.length > 0 ? grid.length * grid[0].length : 0;

            document.getElementById('statsRoads').textContent = `Carreteras: ${roads.length} (${totalRoadCells} celdas)`;
            document.getElementById('statsHouses').textContent = `Casas: ${totalHouses}`;
            document.getElementById('statsRocks').textContent = `Piedras: ${totalRocks}`;
            document.getElementById('statsTrees').textContent = `√Årboles: ${totalTrees}`;
            document.getElementById('statsCells').textContent = `Celdas: ${totalCells}`;
        }

        function showInfo(message) {
            document.getElementById('roadInfo').textContent = message;
        }

        // ============== INICIALIZACI√ìN ==============
        window.addEventListener('load', function () {
            // Initialize default materials
            initializeDefaultMaterials();
            updateLegend();

            generateGrid();

            const canvas = document.getElementById('gridCanvas');
            const container = document.getElementById('canvasContainer');

            // Click handler for road mode
            canvas.addEventListener('click', handleCanvasClick);

            // Zoom with mouse wheel
            container.addEventListener('wheel', handleWheel, { passive: false });

            // Pan with mouse drag
            canvas.addEventListener('mousedown', handlePanStart);
            window.addEventListener('mousemove', handlePanMove);
            window.addEventListener('mouseup', handlePanEnd);

            // Prevent context menu on canvas
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        });
    </script>
</body>
</html>